@page "/search"

@using QuotelyAPP.Models
@using QuotelyAPP.Services
@inject QuoteService QuoteService
@inject FavoritesService FavoritesService
@using System.Linq
@using Microsoft.AspNetCore.Components.Web

<div class="search-page" @onclick="CloseTagDropdown">
    <h2>Search Quotes</h2>
    <p class="search-subtitle">Find the perfect words for any occasion</p>

    <div class="search-inputs">
        <input class="search-input" 
               placeholder="Search by keyword (optional)"
               @bind="keyword"
               @bind:event="oninput" />

        <div class="author-input-wrapper">
            <input class="search-input" 
                   placeholder="Filter by author (type 3+ chars)"
                   value="@author"
                   @oninput="OnAuthorInput" />
            
            @if (authorSuggestions != null && authorSuggestions.Any() && author.Length >= 3)
            {
                <div class="author-suggestions">
                    @foreach (var a in authorSuggestions)
                    {
                        <div class="suggestion-item" @onclick="() => SelectAuthor(a.name)">
                            @a.name
                        </div>
                    }
                </div>
            }
        </div>

        <div class="tag-dropdown-wrapper" @onclick:stopPropagation="true">
            <button class="tag-dropdown-trigger" @onclick="ToggleTagDropdown" type="button">
                <span>@(string.IsNullOrEmpty(selectedTag) ? "Select a tag" : selectedTag)</span>
                <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="#a0785a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="3 4 6 7 9 4"></polyline>
                </svg>
            </button>
            
            @if (isTagDropdownOpen)
            {
                <div class="tag-dropdown-menu">
                    <div class="tag-dropdown-item @(string.IsNullOrEmpty(selectedTag) ? "selected" : "")" 
                         @onclick="() => SelectTag(string.Empty)">
                        @if (string.IsNullOrEmpty(selectedTag))
                        {
                            <svg class="checkmark" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3A3A3A" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        }
                        <span>All tags</span>
                    </div>
                    @foreach (var t in tags)
                    {
                        var tag = t;
                        var isSelected = selectedTag == tag;
                        <div class="tag-dropdown-item @(isSelected ? "selected" : "")" 
                             @onclick="() => SelectTag(tag)">
                            @if (isSelected)
                            {
                                <svg class="checkmark" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3A3A3A" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            }
                            <span>@tag</span>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <button class="btn btn-primary search-btn" @onclick="SearchQuotes">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
        </svg>
        <span>Search Quotes</span>
    </button>

    @if (isLoading)
    {
        <p class="loading-text">Searching...</p>
    }

    @if (!string.IsNullOrEmpty(error))
    {
        <p class="error-text">@error</p>
    }

    @if (results != null && results.results.Any())
    {
        <div class="search-results">
            @foreach (var q in paginatedResults)
            {
                var currentQuote = q;
                var quoteId = currentQuote._id ?? "";
                var isFavorite = favoriteQuotes.ContainsKey(quoteId) && favoriteQuotes[quoteId];
                
                <div class="quote-card" style="position:relative; padding-bottom:40px;">
                    <blockquote>"@currentQuote.content"</blockquote>
                    <p class="author">— @currentQuote.author</p>
                    
                    @if (currentQuote.tags != null && currentQuote.tags.Any())
                    {
                        <div class="tags">
                            @foreach (var tag in currentQuote.tags)
                            {
                                <span>@tag</span>
                            }
                        </div>
                    }
                    
                    <button class="favorite-btn" style="position:absolute; bottom:15px; right:15px; background:none; border:none; cursor:pointer; padding:5px;" @onclick="() => ToggleFavorite(currentQuote)">
                        @if (isFavorite)
                        {
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="#C85A5A" stroke="#C85A5A" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                            </svg>
                        }
                        else
                        {
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#6B5B4F" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                            </svg>
                        }
                    </button>
                </div>
            }
        </div>

        @if (totalPages > 1)
        {
            <div class="pagination">
                <button class="pagination-btn" @onclick="PreviousPage" disabled="@(currentPage == 1)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    <span>Previous</span>
                </button>
                
                <span class="pagination-info">Page @currentPage of @totalPages</span>
                
                <button class="pagination-btn" @onclick="NextPage" disabled="@(currentPage == totalPages)">
                    <span>Next</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
        }
    }
</div>

@code {
    string keyword = "";
    string author = "";
    string selectedTag = "";
    bool isLoading = false;
    string? error;

    QuoteSearchResult? results;
    List<Author>? authorSuggestions;
    List<string> tags = new();
    Dictionary<string, bool> favoriteQuotes = new();
    bool isTagDropdownOpen = false;

    int currentPage = 1;
    int itemsPerPage = 10;
    int totalPages => results?.results != null ? (int)Math.Ceiling(results.results.Count / (double)itemsPerPage) : 1;
    
    List<Quote> paginatedResults
    {
        get
        {
            if (results?.results == null || !results.results.Any())
                return new List<Quote>();
            
            return results.results
                .Skip((currentPage - 1) * itemsPerPage)
                .Take(itemsPerPage)
                .ToList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadTags();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // Close dropdown when clicking outside
        }
    }

    private async Task LoadTags()
    {
        try
        {
            var tagList = await QuoteService.GetTags();
            if (tagList != null)
            {
                tags = tagList
                    .Where(t => !string.IsNullOrEmpty(t.name))
                    .Select(t => t.name!)
                    .Distinct()
                    .OrderBy(t => t)
                    .ToList();
            }
        }
        catch
        {
            tags = new List<string>();
        }
    }

    private async Task SearchQuotes()
    {
        isLoading = true;
        error = null;
        results = null;
        currentPage = 1; // Reset to first page on new search
        StateHasChanged();

        try
        {
            if (string.IsNullOrWhiteSpace(keyword) && 
                string.IsNullOrWhiteSpace(author) && 
                string.IsNullOrWhiteSpace(selectedTag))
            {
                error = "Please enter a search term, author, or select a tag.";
                isLoading = false;
                StateHasChanged();
                return;
            }
            
            List<Quote> allQuotes = new List<Quote>();
            HashSet<string> seenIds = new HashSet<string>();
            
            for (int page = 1; page <= 10; page++)
            {
                var response = await QuoteService.SearchQuotes("", page: page, limit: 150);
                
                if (response?.results == null || !response.results.Any())
                    break;
                
                // Only add quotes we haven't seen before
                foreach (var quote in response.results)
                {
                    if (quote._id != null && !seenIds.Contains(quote._id))
                    {
                        allQuotes.Add(quote);
                        seenIds.Add(quote._id);
                    }
                }
                
                if (response.results.Count < 150)
                    break;
            }
            
            if (allQuotes.Count == 0)
            {
                error = "No response from API.";
                isLoading = false;
                StateHasChanged();
                return;
            }
            
            var filteredResults = allQuotes.AsEnumerable();
            
            if (!string.IsNullOrWhiteSpace(keyword))
            {
                string keywordLower = keyword.ToLowerInvariant();
                filteredResults = filteredResults
                    .Where(q => q.content != null && q.content.ToLowerInvariant().Contains(keywordLower));
            }
            
            if (!string.IsNullOrWhiteSpace(author))
            {
                string authorLower = author.ToLowerInvariant();
                filteredResults = filteredResults
                    .Where(q => q.author != null && q.author.ToLowerInvariant().Contains(authorLower));
            }
            
            if (!string.IsNullOrWhiteSpace(selectedTag))
            {
                filteredResults = filteredResults
                    .Where(q => q.tags != null && q.tags.Any(t => t != null && t.Equals(selectedTag, StringComparison.OrdinalIgnoreCase)));
            }
            
            var filteredList = filteredResults.ToList();
            results = new QuoteSearchResult
            {
                results = filteredList,
                count = filteredList.Count,
                totalCount = filteredList.Count,
                page = 1,
                totalPages = 1
            };

            // Check favorites for all results
            await UpdateFavoriteStatus();

            if (results.results == null || results.results.Count == 0)
            {
                error = "No quotes found matching your search.";
                results = null;
            }
        }
        catch (Exception ex)
        {
            error = $"Error: {ex.Message}";
            results = null;
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task UpdateFavoriteStatus()
    {
        if (results?.results == null)
            return;

        favoriteQuotes.Clear();
        foreach (var quote in results.results)
        {
            if (quote._id != null)
            {
                favoriteQuotes[quote._id] = await FavoritesService.IsFavoriteAsync(quote);
            }
        }
    }

    private async Task OnAuthorInput(ChangeEventArgs e)
    {
        author = e.Value?.ToString() ?? "";
        
        if (author.Length >= 3)
        {
            try
            {
                List<Author> allAuthors = new List<Author>();
                
                for (int page = 1; page <= 10; page++)
                {
                    var result = await QuoteService.SearchAuthors("", page: page, limit: 100);
                    
                    if (result?.results == null || !result.results.Any())
                        break;
                    
                    allAuthors.AddRange(result.results);
                    
                    if (result.results.Count < 100)
                        break;
                }
                
                if (allAuthors.Any())
                {
                    string authorLower = author.ToLowerInvariant();
                    authorSuggestions = allAuthors
                        .Where(a => a.name != null && a.name.ToLowerInvariant().Contains(authorLower))
                        .Take(10)
                        .ToList();
                }
                else
                {
                    authorSuggestions = null;
                }
            }
            catch
            {
                authorSuggestions = null;
            }
        }
        else
        {
            authorSuggestions = null;
        }
        
        StateHasChanged();
    }

    private void SelectAuthor(string authorName)
    {
        author = authorName;
        authorSuggestions = null;
        StateHasChanged();
    }

    private async Task ToggleFavorite(Quote quote)
    {
        if (quote?._id == null)
            return;

        await FavoritesService.ToggleFavoriteAsync(quote);
        favoriteQuotes[quote._id] = await FavoritesService.IsFavoriteAsync(quote);
        StateHasChanged();
    }

    private void ToggleTagDropdown()
    {
        isTagDropdownOpen = !isTagDropdownOpen;
    }

    private void SelectTag(string tag)
    {
        selectedTag = tag;
        isTagDropdownOpen = false;
        StateHasChanged();
    }

    private void CloseTagDropdown()
    {
        if (isTagDropdownOpen)
        {
            isTagDropdownOpen = false;
            StateHasChanged();
        }
    }

    private void PreviousPage()
    {
        if (currentPage > 1)
        {
            currentPage--;
            StateHasChanged();
        }
    }

    private void NextPage()
    {
        if (currentPage < totalPages)
        {
            currentPage++;
            StateHasChanged();
        }
    }
}

